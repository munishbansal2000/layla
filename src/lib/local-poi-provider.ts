/**
 * Local POI Provider
 *
 * Provides place data from local Japan POI datasets for testing.
 * Uses pre-built indexes for O(1) name lookups.
 *
 * Data Source: OpenStreetMap + Wikidata + Wikimedia Commons
 * Generated by: scripts/build-japan-poi-dataset.mjs
 */

import { promises as fs } from "fs";
import path from "path";

// ============================================
// TYPES
// ============================================

export interface LocalPOI {
  id: string;
  name: string;
  nameJa?: string;
  nameEn?: string;
  coordinates: { lat: number; lng: number };
  address?: string;
  neighborhood?: string;
  city: string;
  country: string;
  category: string;
  subcategory?: string;
  website?: string;
  phone?: string;
  openingHours?: string;
  photos: string[];
  rating: number;
  reviewCount: number;
  description?: string;
  wikipediaUrl?: string;
  wikidataId?: string;
  sources: string[];
  lastUpdated: string;
}

interface CityData {
  city: string;
  cityJa: string;
  country: string;
  totalPOIs: number;
  categories: Record<string, number>;
  lastUpdated: string;
  pois: LocalPOI[];
}

interface CityIndex {
  city: string;
  cityKey: string;
  totalPOIs: number;
  lastUpdated: string;
  byName: Record<string, number>;
  byNameNormalized: Record<string, number>;
  byCategory: Record<string, number[]>;
  byNeighborhood: Record<string, number[]>;
  bySubcategory: Record<string, number[]>;
}

interface GlobalIndex {
  [cityKey: string]: {
    file: string;
    count: number;
    categories: Record<string, number>;
  };
}

// ============================================
// CONFIGURATION
// ============================================

const DATA_DIR = process.env.LOCAL_POI_DIR || "./data/japan-pois";

// City name normalization map
const CITY_ALIASES: Record<string, string> = {
  tokyo: "tokyo",
  "東京": "tokyo",
  kyoto: "kyoto",
  "京都": "kyoto",
  osaka: "osaka",
  "大阪": "osaka",
  nara: "nara",
  "奈良": "nara",
  hiroshima: "hiroshima",
  "広島": "hiroshima",
  hakone: "hakone",
  "箱根": "hakone",
};

// ============================================
// CACHE
// ============================================

// In-memory cache for loaded data
const dataCache = new Map<string, CityData>();
const indexCache = new Map<string, CityIndex>();
let globalIndex: GlobalIndex | null = null;

// ============================================
// UTILITY FUNCTIONS
// ============================================

function normalizeName(name: string): string {
  return name
    .toLowerCase()
    .replace(/['']/g, "'")
    .replace(/[""]/g, '"')
    .replace(/\s+/g, " ")
    .trim();
}

function normalizeCityKey(city: string): string | null {
  const normalized = city.toLowerCase().trim();
  return CITY_ALIASES[normalized] || null;
}

/**
 * Calculate string similarity (Levenshtein-based)
 */
function similarity(s1: string, s2: string): number {
  const longer = s1.length > s2.length ? s1 : s2;
  const shorter = s1.length > s2.length ? s2 : s1;

  if (longer.length === 0) return 1.0;

  const editDistance = levenshteinDistance(longer, shorter);
  return (longer.length - editDistance) / longer.length;
}

function levenshteinDistance(s1: string, s2: string): number {
  const costs: number[] = [];
  for (let i = 0; i <= s1.length; i++) {
    let lastValue = i;
    for (let j = 0; j <= s2.length; j++) {
      if (i === 0) {
        costs[j] = j;
      } else if (j > 0) {
        let newValue = costs[j - 1];
        if (s1.charAt(i - 1) !== s2.charAt(j - 1)) {
          newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;
        }
        costs[j - 1] = lastValue;
        lastValue = newValue;
      }
    }
    if (i > 0) costs[s2.length] = lastValue;
  }
  return costs[s2.length];
}

// ============================================
// DATA LOADING
// ============================================

async function loadGlobalIndex(): Promise<GlobalIndex | null> {
  if (globalIndex) return globalIndex;

  try {
    const indexPath = path.join(DATA_DIR, "index.json");
    const content = await fs.readFile(indexPath, "utf-8");
    globalIndex = JSON.parse(content);
    return globalIndex;
  } catch (error) {
    console.warn("[LocalPOI] Global index not found:", error);
    return null;
  }
}

async function loadCityIndex(cityKey: string): Promise<CityIndex | null> {
  const cached = indexCache.get(cityKey);
  if (cached) return cached;

  try {
    const indexPath = path.join(DATA_DIR, `${cityKey}.index.json`);
    const content = await fs.readFile(indexPath, "utf-8");
    const index = JSON.parse(content) as CityIndex;
    indexCache.set(cityKey, index);
    return index;
  } catch (error) {
    console.warn(`[LocalPOI] City index not found for ${cityKey}:`, error);
    return null;
  }
}

async function loadCityData(cityKey: string): Promise<CityData | null> {
  const cached = dataCache.get(cityKey);
  if (cached) return cached;

  try {
    const dataPath = path.join(DATA_DIR, `${cityKey}.json`);
    const content = await fs.readFile(dataPath, "utf-8");
    const data = JSON.parse(content) as CityData;
    dataCache.set(cityKey, data);
    return data;
  } catch (error) {
    console.warn(`[LocalPOI] City data not found for ${cityKey}:`, error);
    return null;
  }
}

// ============================================
// PUBLIC API
// ============================================

/**
 * Check if local POI data is available for a city
 */
export async function hasLocalData(city: string): Promise<boolean> {
  const cityKey = normalizeCityKey(city);
  if (!cityKey) return false;

  const index = await loadGlobalIndex();
  return index !== null && cityKey in index;
}

/**
 * Get list of available cities with local POI data
 */
export async function getAvailableCities(): Promise<string[]> {
  const index = await loadGlobalIndex();
  if (!index) return [];
  return Object.keys(index);
}

/**
 * Find a POI by exact name match
 */
export async function findByName(
  name: string,
  city: string
): Promise<LocalPOI | null> {
  const cityKey = normalizeCityKey(city);
  if (!cityKey) return null;

  const index = await loadCityIndex(cityKey);
  if (!index) return null;

  // Try exact match first
  let poiIndex = index.byName[name];

  // Try normalized match
  if (poiIndex === undefined) {
    const normalized = normalizeName(name);
    poiIndex = index.byNameNormalized[normalized];
  }

  if (poiIndex === undefined) return null;

  // Load full data to get the POI
  const data = await loadCityData(cityKey);
  if (!data || poiIndex >= data.pois.length) return null;

  return data.pois[poiIndex];
}

/**
 * Find POIs by fuzzy name match
 */
export async function findByFuzzyName(
  name: string,
  city: string,
  options: {
    maxResults?: number;
    minSimilarity?: number;
    category?: string;
  } = {}
): Promise<LocalPOI[]> {
  const { maxResults = 5, minSimilarity = 0.6, category } = options;

  const cityKey = normalizeCityKey(city);
  if (!cityKey) return [];

  const index = await loadCityIndex(cityKey);
  if (!index) return [];

  const data = await loadCityData(cityKey);
  if (!data) return [];

  const normalizedSearch = normalizeName(name);
  const candidates: Array<{ poi: LocalPOI; score: number }> = [];

  // Get category filter if specified
  let categoryIndices: Set<number> | null = null;
  if (category && index.byCategory[category]) {
    categoryIndices = new Set(index.byCategory[category]);
  }

  // Search through normalized names
  for (const [normalizedName, poiIndex] of Object.entries(index.byNameNormalized)) {
    // Apply category filter
    if (categoryIndices && !categoryIndices.has(poiIndex)) continue;

    // Calculate similarity
    const score = similarity(normalizedSearch, normalizedName);

    // Also check if search term is contained in name
    const containsBonus = normalizedName.includes(normalizedSearch) ? 0.2 : 0;
    const finalScore = Math.min(1, score + containsBonus);

    if (finalScore >= minSimilarity) {
      const poi = data.pois[poiIndex];
      if (poi) {
        candidates.push({ poi, score: finalScore });
      }
    }
  }

  // Sort by score and return top results
  candidates.sort((a, b) => b.score - a.score);
  return candidates.slice(0, maxResults).map((c) => c.poi);
}

/**
 * Find POIs by category
 */
export async function findByCategory(
  city: string,
  category: string,
  options: {
    maxResults?: number;
    neighborhood?: string;
  } = {}
): Promise<LocalPOI[]> {
  const { maxResults = 20, neighborhood } = options;

  const cityKey = normalizeCityKey(city);
  if (!cityKey) return [];

  const index = await loadCityIndex(cityKey);
  if (!index) return [];

  const data = await loadCityData(cityKey);
  if (!data) return [];

  // Get indices for category
  const categoryIndices = index.byCategory[category.toLowerCase()];
  if (!categoryIndices || categoryIndices.length === 0) return [];

  // Apply neighborhood filter if specified
  let filteredIndices = categoryIndices;
  if (neighborhood) {
    const neighborhoodIndices = new Set(
      index.byNeighborhood[neighborhood.toLowerCase()] || []
    );
    filteredIndices = categoryIndices.filter((i) => neighborhoodIndices.has(i));
  }

  // Get POIs
  const pois: LocalPOI[] = [];
  for (const idx of filteredIndices.slice(0, maxResults)) {
    if (data.pois[idx]) {
      pois.push(data.pois[idx]);
    }
  }

  // Sort by rating
  pois.sort((a, b) => b.rating - a.rating);

  return pois;
}

/**
 * Find POIs near a coordinate
 */
export async function findNearby(
  city: string,
  lat: number,
  lng: number,
  options: {
    maxResults?: number;
    radiusKm?: number;
    category?: string;
  } = {}
): Promise<LocalPOI[]> {
  const { maxResults = 10, radiusKm = 1, category } = options;

  const cityKey = normalizeCityKey(city);
  if (!cityKey) return [];

  const data = await loadCityData(cityKey);
  if (!data) return [];

  // Calculate distance for each POI
  const candidates: Array<{ poi: LocalPOI; distance: number }> = [];

  for (const poi of data.pois) {
    // Apply category filter
    if (category && poi.category !== category.toLowerCase()) continue;

    // Haversine distance calculation
    const R = 6371; // Earth radius in km
    const dLat = ((poi.coordinates.lat - lat) * Math.PI) / 180;
    const dLon = ((poi.coordinates.lng - lng) * Math.PI) / 180;
    const a =
      Math.sin(dLat / 2) * Math.sin(dLat / 2) +
      Math.cos((lat * Math.PI) / 180) *
        Math.cos((poi.coordinates.lat * Math.PI) / 180) *
        Math.sin(dLon / 2) *
        Math.sin(dLon / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    const distance = R * c;

    if (distance <= radiusKm) {
      candidates.push({ poi, distance });
    }
  }

  // Sort by distance and return top results
  candidates.sort((a, b) => a.distance - b.distance);
  return candidates.slice(0, maxResults).map((c) => c.poi);
}

/**
 * Get statistics about available local data
 */
export async function getStats(): Promise<{
  totalCities: number;
  totalPOIs: number;
  cities: Record<string, { count: number; categories: Record<string, number> }>;
}> {
  const index = await loadGlobalIndex();
  if (!index) {
    return { totalCities: 0, totalPOIs: 0, cities: {} };
  }

  let totalPOIs = 0;
  const cities: Record<string, { count: number; categories: Record<string, number> }> = {};

  for (const [cityKey, cityInfo] of Object.entries(index)) {
    totalPOIs += cityInfo.count;
    cities[cityKey] = {
      count: cityInfo.count,
      categories: cityInfo.categories,
    };
  }

  return {
    totalCities: Object.keys(index).length,
    totalPOIs,
    cities,
  };
}

/**
 * Clear the in-memory cache (useful for testing)
 */
export function clearCache(): void {
  dataCache.clear();
  indexCache.clear();
  globalIndex = null;
}
